---
author: Data Intuitive
date: Tuesday - January 26, 2021
mainfont: Roboto Condensed
monofont: Source Code Pro
monofontoptions: Scale=0.7
monobackgroundcolor: lightgrey
title: Viash Workshop 1 - Viahs Components
---

```{r setup, include = FALSE}
# set default chunk options
knitr::opts_chunk$set(
  echo = TRUE,
  comment = "",
  collapse = TRUE,
  prompt = TRUE
  # engine.opts = list(bash = "-l")
)
```

# Introduction

In this section, we cover all the components of the Civilization postgame generation pipeline one by one, just like in the [introductory section]. Before doing so, we first introduce the concept of a _namespace_.

# Namespaces in [viash]

Once you start to make components with [viash] and combining them in larger scripts, workflows or pipelines you will quickly notice that some kind of grouping comes in handy:

1. Grouping helps in the bookkeeping related to functionality that is covered using components
2. Grouping helps in separating different concerns: different people may be interested in different types of components with a grouping mechanism each can focus on his their own domain.
3. Grouping helps in allowing to develop different sets of components in parallel and then later bringing those together in a larger project

We call a group of components a _namespace_.

[Viash] has a few ways to associate a namespace to a components:

1. ~~By means of a `namespace` attribute in the [viash] config~~
2. ~~By means of command line parameter when building an executable~~
3. By means of structuring the components properly and using the `viash ns` subcommand

Let us give an example of the first 2, option 3 will be used later in this section.

## An example

We introduce a very simple component, one that only reports the release of an Alpine docker container, albeit the component could be used to `cat` the contents of other dockerized files as well:

```{sh echo = F, results = "asis"}
../scripts/cat_format src/container_cat/config.vsh.yaml
```

We introduce two Docker platforms that can be distinguished by id (`docker1` and `docker2`). Let us illustrate their use:

`docker1` platform:

```{sh}
viash run src/container_cat/config.vsh.yaml -p docker1
```

`docker2` platform:

```{sh}
viash run src/container_cat/config.vsh.yaml -p docker2
```

The component can be used to `cat` the contents of other files as well:

```{sh}
viash run src/container_cat/config.vsh.yaml -p docker1 -- /etc/hosts
```

__Remark__: Please note that we did not specify the argument as `type: file` because that would automount the _host_'s filesystem in the container (or at least attempt to). In this case, we effectively want to look inside the container.

## A namespace: `container_tools`

Our `container_cat` example fits nicely in a collection of components to deal with containers and so we want to attach the namespace `container_tools` to it. Let's see how this can be done.

## The example in a namespace

We take the example from above, but now store it in a directory hierarchy like this:

```{sh}
tree src/container_tools
```

The directory `container_tools` corresponds to the name of the namespace. Apart from this, there is no difference in how `container_cat` is defined.

We can now use the `viash ns` subcommand like this:

```{sh}
viash ns build -n container_tools
```

We specify the name of the namespace using the `-n` parameter. In this case, there is only one component in this namespace, but it contains two platforms. The `viash ns` command _builds_ a _target_ for every platform it detects unless an optional `-p` is specified in the command above.

As a matter of fact, even the `-n` option can be omitted in which case _all_ namespaces under `src` will be parsed.

This is a very effective way of keeping a collection of components under `src` grouped in namespaces. Different namespaces could be split across different directories or even source repositories and then combined on the level of `viash` by specifying the _target_ directory (`target/` by default).

# `civ6_save_renderer` namespace

Looking at the contents of `src/civ6_save_renderer`, we notice that `civ6_save_renderer` is a namespace that contains a number of components:

```{sh}
tree src/civ6_save_renderer
```


We cover the components one by one in what follows and discuss any specificities that we encounter underway.

## `parse_header`

Let us start with `parse_header`, it parses the headers of the save files.

```{sh echo = F, results = "asis"}
../scripts/cat_format src/civ6_save_renderer/parse_header/config.vsh.yaml
```

```{sh echo = F, results = "asis"}
../scripts/cat_format src/civ6_save_renderer/parse_header/script.sh
```

## `parse_map`

The next component is `parse_map`. It is similar in nature that `parse_header` but this time we need a Javascript library to get the file parsed properly:

```{sh echo = F, results = "asis"}
../scripts/cat_format src/civ6_save_renderer/parse_map/config.vsh.yaml
```

```{sh echo = F, results = "asis"}
../scripts/cat_format src/civ6_save_renderer/parse_map/script.js
```

This last script uses the following helper script: `src/civ6_save_renderer/parse_map/helper.js` but it is a bit too long to represent here in this document.

The container to run in is an off-the-shelve `node` container that will be pulled automatically at first use (or when calling `---setup` on the executable).

This component is not very special in itself, but we would like to point out that the power of [viash] lies in making sure that not only `script.js` are passed to the container at runtime, but also the `helper.js` file that is used by `script.js`. This is all done seamlessly without a need for the user to understand what is happening under the hood.

Please note the ease of use of having `par["input"]` etc. automatically at your disposal coming from the CLI arguments specified with the component configuration.

Imagine you would have to do this manually using the Docker CLI?

## `plot_map`

Based on the output from `parse_header` and `parse_map`, we can now generate a plot using `plot_map`. We have some R code to do this but the code in itself uses some R libraries that are not standard. This is again a perfect use-case for a containerized solution that is leveraged using [viash]!

```{sh echo = F, results = "asis"}
../scripts/cat_format src/civ6_save_renderer/plot_map/config.vsh.yaml
```

```{sh echo = F, results = "asis"}
../scripts/cat_format src/civ6_save_renderer/plot_map/script.R
```

Again there is a helper script `helper.R` that we do not completely render in this document but can easily be retrieved by looking at the sources.

This component takes 2 input files, a `yaml` file and a `tsv` file

The container for this component is based on `rocker/tidyverse` but there are some modifications that are applied. Additional R libraries are installed, 5 from the CRAN database, 1 from Github. This functionality covers a major reason to create a custom `Dockerfile` an thus container image: customizing a base container to suite ones needs. Adding the customizations using the [viash] configuration entails similar benefits to [viash] generating the command-line parsing code, namely standardization.

__Remark__: Please note that also here `par$yaml`, `par$tsv`, ... are automatically at your disposal and are passed from the wrapped (and containerized) executable. The `script.R` file even contains a (commented) code block that if uncommented allows one to develop and run the script (in or outside a container) without [viash]. Often times, component development will be done like this, using tools like RStudio or Jupyter notebooks on the native system and once the script is ready it is then converted to a ([viash]) component.

## `convert_plot`

We covered the `convert_plot` component in the previous section and so will only quickly render the relevant source files here:

```{sh echo = F, results = "asis"}
../scripts/cat_format src/civ6_save_renderer/convert_plot/config.vsh.yaml
```

```{sh echo = F, results = "asis"}
../scripts/cat_format src/civ6_save_renderer/convert_plot/script.sh
```

## `combine_plots`

We covered the `combine_plots` component in the previous section and so will only quickly render the relevant source files here:

```{sh echo = F, results = "asis"}
../scripts/cat_format src/civ6_save_renderer/combine_plots/config.vsh.yaml
```

```{sh echo = F, results = "asis"}
../scripts/cat_format src/civ6_save_renderer/combine_plots/script.sh
```

# Building the namespace

We can easily convert the full contents this namespace into executables using:

```{sh}
viash ns build -n civ6_save_renderer
```

__Remark__: Please note that both the `docker` platform as well as the `native` platform are taken into account. Because most people will not have the necessary tools for running the different steps, we will not build the executables for the `native` platform:

```{sh}
rm -r target
```

And then:

```{sh}
viash ns build -n civ6_save_renderer -p docker
```

This is what the `target` directory looks like now:

```{sh}
tree target/
```

Please notice a few things:

- Every components has its own directory under `target/<platform>/<namespace>/`
- The `script.R`, `script.sh`, ... files are contained in the respective executables, helper files are passed at runtime.
- Every _target_ component directory contains a `viash.yaml` file which contains necessary (meta) information for reproducing the component

Using the respective (containerized) tools is now as easy as, for instance,

```{sh}
target/docker/civ6_save_renderer/parse_header/parse_header -i ../data/AutoSave_0158.Civ6Save -o /tmp/output.yaml
```

```{sh results="asis", echo = F}
../scripts/cat_format /tmp/output.yaml --cut
```

[viash]: https://github.com/data-intuitive/viash
