---
author: Data Intuitive
date: Tuesday - January 26, 2021
mainfont: Roboto Condensed
monofont: Source Code Pro
monofontoptions: Scale=0.7
monobackgroundcolor: lightgrey
title: Viash Workshop 1 - Viahs Components
---

```{r setup, include = FALSE}
# set default chunk options
knitr::opts_chunk$set(
  echo = TRUE,
  comment = "",
  collapse = TRUE,
  prompt = TRUE
  # engine.opts = list(bash = "-l")
)
```

# Introduction

In this section, we cover all the components of the Civilization postgame generation pipeline one by one, just like in the [introductory section]. Before doing so, we first introduce the concept of a _namespace_.

# Namespaces in [viash]

Once you start to make components with [viash] and combining them in larger scripts, workflows or pipelines you will quickly notice that some kind of grouping comes in handy:

1. Grouping helps in the bookkeeping related to functionality that is covered using components
2. Grouping helps in separating different concerns: different people may be interested in different types of components with a grouping mechanism each can focus on his their own domain.
3. Grouping helps in allowing to develop different sets of components in parallel and then later bringing those together in a larger project

We call a group of components a _namespace_.

[Viash] has a few ways to associate a namespace to a components:

1. ~~By means of a `namespace` attribute in the [viash] config~~
2. ~~By means of command line parameter when building an executable~~
3. By means of structuring the components properly and using the `viash ns` subcommand

Let us give an example of the first 2, option 3 will be used later in this section.

## An example

We introduce a very simple component, one that only reports the release of an Alpine docker container, albeit the component could be used to `cat` the contents of other dockerized files as well:

```{sh echo = F, results = "asis"}
../scripts/cat_format src/container_cat/config.vsh.yaml
```

We introduce two Docker platforms that can be distinguished by id (`docker1` and `docker2`). Let us illustrate their use:

`docker1` platform:

```{sh}
viash run src/container_cat/config.vsh.yaml -p docker1
```

`docker2` platform:

```{sh}
viash run src/container_cat/config.vsh.yaml -p docker2
```

The component can be used to `cat` the contents of other files as well:

```{sh}
viash run src/container_cat/config.vsh.yaml -p docker1 -- /etc/hosts
```

__Remark__: Please note that we did not specify the argument as `type: file` because that would automount the _host_'s filesystem in the container (or at least attempt to). In this case, we effectively want to look inside the container.

## A namespace: `container_tools`

Our `container_cat` example fits nicely in a collection of components to deal with containers and so we want to attach the namespace `container_tools` to it.

First, we will build the executable for `docker1`:

```{sh}
viash build src/container_cat/config.vsh.yaml -p docker1 -o bin/
```

## The example in a namespace

We take the example from above, but now store it in a directory hierarchy like this:

```{sh}
tree src/container_tools
```

The directory `container_tools` corresponds to the name of the namespace. Apart from this, there is no difference in how `container_cat` is defined.

We can now use the `viash ns` subcommand like this:

```{sh}
viash ns build -n container_tools
```

We specify the name of the namespace using the `-n` parameter. In this case, there is only one component in this namespace, but it contains two platforms. The `viash ns` command _builds_ a _target_ for every platform it detects unless an optional `-p` is specified in the command above.

As a matter of fact, even the `-n` option can be omitted in which case _all_ namespaces under `src` will be parsed.

This is a very effective way of keeping a collection of components under `src` grouped in namespaces. Different namespaces could be split across different directories or even source repositories and then combined on the level of `viash` by specifying the _target_ directory (`target/` by default).

# `civ6_save_renderer` namespace

Looking at the contents of `src/civ6_save_renderer`, we notice that `civ6_save_renderer` is a namespace that contains a number of components:

```{sh}
tree src/civ6_save_renderer
```

We can easily convert the full contents this namespace into executables using:

```{sh}
viash ns build -n civ6_save_renderer
```

We cover the components one by one in what follows and discuss any specificities that we encounter underway.

## `parse_header`

Let us start with `parse_header`, it parses the headers of the save files.

```{sh echo = F, results = "asis"}
../scripts/cat_format src/civ6_save_renderer/parse_header/config.vsh.yaml
```

```{sh echo = F, results = "asis"}
../scripts/cat_format src/civ6_save_renderer/parse_header/script.sh
```

## `parse_map`

The next component is `parse_map`. It is similar in nature that `parse_header`.

```{sh echo = F, results = "asis"}
../scripts/cat_format src/civ6_save_renderer/parse_map/config.vsh.yaml
```

```{sh echo = F, results = "asis"}
../scripts/cat_format src/civ6_save_renderer/parse_map/script.sh
```






[viash]: https://github.com/data-intuitive/viash
