---
author: Data Intuitive
date: Tuesday - January 26, 2021
mainfont: Roboto Condensed
monofont: Source Code Pro
monofontoptions: Scale=0.7
monobackgroundcolor: lightgrey
title: "Creating components"
---

# Creating components

```{r setup, include = FALSE}
# set default chunk options
knitr::opts_chunk$set(
  echo = TRUE,
  comment = "",
  collapse = TRUE,
  prompt = TRUE
  # engine.opts = list(bash = "-l")
)
```

With the information from the previous section, we will tackle two from the components in detail in this section:

- `convert_plot`
- `combine_plots`

Both are explained in [section 1] above.

# `convert_plot`

`convert_plot` should convert a PDF map into a `.png` version. [ImageMagick] is a suite of command line tools for UNIX-like systems that can achieve this simply by running

```
convert input.pdf -flatten output.png
```

Additional arguments can be provided, but are not required since [ImageMagick] is pretty good at getting the defaults right. [ImageMagick] will probably not be on everyone's machine as a locally installed tool, however. We would to enable the conversion from pdf to png in a seamless way. Let's use [viash] for this...

## The viash configuration

First of all, we will store all files related to one _component_ in a separate directory and give it the name of the component:

```{sh}
ls src/convert_plot
```

Just like in the [viash] primer (of the previous section) there is a [viash] config (`config.vsh.yaml`) and a script (`script.sh`). Let us take a closer look at both of these:

```{sh echo = F, results = "asis"}
../scripts/cat_format src/convert_plot/config.vsh.yaml
```

```{sh echo = F, results = "asis"}
../scripts/cat_format src/convert_plot/script.sh
```

Let us dissect these two files step by step.

### Arguments

The script is not so much different from the CLI example we gave above. The only difference is that 2 variables are used: `$par_input` and `$par_output`. We use double quotes around the variables, this is a good policy in general.

The argument `--input` defined in the config is automatically associated with `$par_input` and likewise for `--output`. This makes it easy to write scripts and immediately get a command-line parser for free when using [viash].

If the script is more complicated than just this one instruction (it usually is), it is possible to set default values for those parameters in the script itself. This way, the script can be developed on its own without requiring [viash] directly. This can be achieved by including the following code block at the top of the file. This syntax is similar but slightly different depending on the scripting lanuage used.
```sh
## VIASH START
par_input=input.pdf
par_output=output.png
## VIASH END
```

If we focus on `--input` for a second, we notice the following attributes:

- `-i` is a (short) alternative for the longer `--input`
- The value for this argument is of type `file` which means it's either a file or a directory.
- With `required: true` we make this argument a mandatory one
- The default value for the argument is `input.pdf`
- For argument of type file like this one, we can ask [viash] to check if the file/directory exists prior to running.
- The `description` attribute contains a human-readable description of this argument/parameter.

Similar attributes can be found for `--output` with one difference:

- `direction: output` denotes that this argument denotes an output file/option.

In fact, `--input` also has a (hidden) `direction: input` associated to it by default.

### Resources

We've covered how to specify resources earlier in the previous section. Suffice to say here that we point to a bash script that contains the actual command-line instruction.

### Platforms

Two platforms are defined in the present case: a Docker one and a native one. We point the Docker platform to an [existing Docker image](https://hub.docker.com/r/dpokidov/imagemagick/) available on Docker Hub.

## Building the executable

Building an executable can be done just like before. We assume ImageMagick is not installed on the local system and thus build the Docker version:

```{sh}
viash build src/convert_plot/config.vsh.yaml -o bin/ -p docker
```

We specify the `docker` platform explicitly although that is not really necessary because of the order of the platforms in the viash config. The resulting script is stored under `bin` relative to the current working directory.

We ask the generated executable to run the necessary setup. In this case, it means _pulling_ the appropriate docker image from Docker Hub.

```{sh results="hold"}
bin/convert_plot ---setup
```

We can retrieve the _help_

```{sh}
bin/convert_plot -h
```

## Running the executable

Now that everything is up and running, we can start converting images. Let us first generate a simple PDF file with the help of [viash]. We start by preparing a directory to store the data:

```{sh}
mkdir -p data/
```

And then use a simple mechanism to create a very basis PDF from the [viash] help output:

```{sh}
viash -h | groff -mom -T pdf > data/viash.pdf
```

This generates `data/viash.pdf` in order to verify if our conversion step works:

```{sh, engine.opts='-l'}
bin/convert_plot -i data/viash.pdf -o data/viash.png
```

Ok, so this should work now:

<!-- See: https://www.xaprb.com/blog/how-to-style-images-with-markdown/ -->

![PNG from PDF using convert_plot](data/viash.png)


## Without viash

Please note that in the above example, the input file and output file reside on the host image while the conversion process is running inside a Docker container. If we would want to achieve this without [viash], we would need something like this:

```sh
docker run -i -v `pwd`:/mount dpokidov/ImageMagick /mount/data/viash.pdf -flatten /mount/data/viash.png
```

This requires some mental bookkeeping to understand the difference between the host's file system and the one inside the container. It also requires one to know how the container's commands are parsed. In this case the `convert` command from ImageMagick is automatically called with the options we provide. But that may be different for every container and depends on the contents of the `Dockerfile`.

Also, while the above explicit `docker` command achieves our aim, it does not fully cover the use-case that we tackle using [viash]. For a correct comparison, we would have to run our custom script in the container. But then, we would have to make a few updates:

1. Include command-line argument parsing in the `script.sh` file so that we can provide input and output parameters to it.
2. _Install_ the modified `script.sh` file inside the container, or somehow _mount_ the location of the executable inside the container such that it can be found.

In other words:

> Using [viash] all this is greatly simplified and wrapped in one executable, command-line parsing comes for free.

# `combine_plots`

This _component_ combines a number of `png` files in to one single movie (`webm` format).

## The viash configuration

First of all, we will store all files related to one _component_ in a separate directory and give it the name of the component:

```{sh}
ls src/combine_plots
```

Again, there is a [viash] config (`config.vsh.yaml`) and a script (`script.sh`). Let us take a closer look at both of these:

```{sh echo = F, results = "asis"}
../scripts/cat_format src/combine_plots/config.vsh.yaml
```

```{sh echo = F, results = "asis"}
../scripts/cat_format src/combine_plots/script.sh
```

### Arguments

This component is similar to the one above with one major difference: we need to specify _multiple_ input file names. This can easily be done with [viash] by specifying `multiple: true` in the configuration of the `--input` argument. By default [viash] will pass the value of this option to the wrapped script depending on the type of script. In the case of `bash`, this is simply a string with a delimiter for the individual values (`:` by default). For `Python` and `R` etc., it is passed as a simple collection (list, array).

The script that is run converts the following value `--input`:

```
path1:path2:path3
```

into

```
-i path1 -i path2 -o path3
```

by means of the `sed` instruction.

The rest is only a matter of getting the command line parameters for `ffmpeg` right.

### Platforms

Two platforms are again defined in the present case: a Docker one and a native one. We point the Docker platform to an [ existing Docker image](https://hub.docker.com/r/jrottenbergj/ffmpeg/) available on Docker Hub.

## Running the executable

Let us create one additional `png` file by using the same _technique_ as before, this time creating a PDF file with just the output of an empty [viash] run.

```{sh}
viash | groff -mom -T pdf > data/viash1.pdf
```

This generates `data/viash.pdf` in order to verify if our conversion step works:

```{sh, engine.opts='-l'}
bin/convert_plot -i data/viash1.pdf -o data/viash1.png
```

Ok, so this should work now:

![PNG from PDF using convert_plot](data/viash1.png)


We now have 2 `png` files and should be able to run our `combine_plots` component. But first, we'll build the executable:

```{sh}
viash build src/combine_plots/config.vsh.yaml -o bin/ -p docker
```

Make sure the container is present:

```{sh}
bin/combine_plots ---setup
```

And than executing the executable:

```{sh}
bin/combine_plots --input data/viash.png:data/viash1.png --output data/output.webm --framerate 1
```

The result this simple _video_ that can hardly be called a video:

[![](data/output.png)](data/output.webm)

In the next section, we will cover _all_ the components of the postgame pipeline one by one.

[viash]: https://github.com/data-intuitive/viash
